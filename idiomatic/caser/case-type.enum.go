//************************************************************************************
//*                                                                                  *
//* ===== DO NOT EDIT =====                                                          *
//* Manual changes will be overwritten.                                              *
//* Generated by github.com/boundedinfinity/enumer                                   *
//*                                                                                  *
//************************************************************************************

package caser

import (
	"database/sql/driver"
	"encoding/xml"
	"fmt"

	"github.com/boundedinfinity/enumer"
)

type CaseType string

// /////////////////////////////////////////////////////////////////
//  CaseType Stringer implemenation
// /////////////////////////////////////////////////////////////////

func (t CaseType) String() string {
	return string(t)
}

// /////////////////////////////////////////////////////////////////
//  CaseType JSON marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t CaseType) MarshalJSON() ([]byte, error) {
	return enumer.MarshalJSON(t)
}

func (t *CaseType) UnmarshalJSON(data []byte) error {
	return enumer.UnmarshalJSON(data, t, CaseTypes.Parse)
}

// /////////////////////////////////////////////////////////////////
//  CaseType YAML marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t CaseType) MarshalYAML() (interface{}, error) {
	return enumer.MarshalYAML(t)
}

func (t *CaseType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	return enumer.UnmarshalYAML(unmarshal, t, CaseTypes.Parse)
}

// /////////////////////////////////////////////////////////////////
//  CaseType XML marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t CaseType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return enumer.MarshalXML(t, e, start)
}

func (t *CaseType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	return enumer.UnmarshalXML(t, CaseTypes.Parse, d, start)
}

// /////////////////////////////////////////////////////////////////
//  CaseType SQL Database marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t CaseType) Value() (driver.Value, error) {
	return enumer.Value(t)
}

func (t *CaseType) Scan(value interface{}) error {
	return enumer.Scan(value, t, CaseTypes.Parse)
}

// /////////////////////////////////////////////////////////////////
//
//  Enumeration
//
// /////////////////////////////////////////////////////////////////

type caseTypes struct {
	Camel      CaseType
	Kebab      CaseType
	KebabLower CaseType
	KebabUpper CaseType
	Pascal     CaseType
	Phrase     CaseType
	Snake      CaseType
	SnakeLower CaseType
	SnakeUpper CaseType
	Unknown    CaseType
	Values     []CaseType
	Err        error
}

var CaseTypes = caseTypes{
	Camel:      CaseType("camel"),
	Kebab:      CaseType("kebab"),
	KebabLower: CaseType("kebab-lower"),
	KebabUpper: CaseType("kebab-upper"),
	Pascal:     CaseType("pascal"),
	Phrase:     CaseType("phrase"),
	Snake:      CaseType("snake"),
	SnakeLower: CaseType("snake-lower"),
	SnakeUpper: CaseType("snake-upper"),
	Unknown:    CaseType("unknown"),
	Err:        fmt.Errorf("invalid CaseType"),
}

func init() {
	CaseTypes.Values = []CaseType{
		CaseTypes.Camel,
		CaseTypes.Kebab,
		CaseTypes.KebabLower,
		CaseTypes.KebabUpper,
		CaseTypes.Pascal,
		CaseTypes.Phrase,
		CaseTypes.Snake,
		CaseTypes.SnakeLower,
		CaseTypes.SnakeUpper,
		CaseTypes.Unknown,
	}
}

func (t caseTypes) newErr(a any, values ...CaseType) error {
	return fmt.Errorf(
		"invalid %w value '%v'. Must be one of %v",
		CaseTypes.Err,
		a,
		enumer.Join(values, ", "),
	)
}

func (t caseTypes) ParseFrom(v string, values ...CaseType) (CaseType, error) {
	var found CaseType
	var ok bool

	for _, value := range values {
		if enumer.IsEq[string, CaseType](v)(value) {
			found = value
			ok = true
			break
		}
	}

	if !ok {
		return found, t.newErr(v, values...)
	}

	return found, nil
}

func (t caseTypes) Parse(v string) (CaseType, error) {
	return t.ParseFrom(v, CaseTypes.Values...)
}

func (t caseTypes) IsFrom(v string, values ...CaseType) bool {
	for _, value := range values {
		if enumer.IsEq[string, CaseType](v)(value) {
			return true
		}
	}
	return false
}

func (t caseTypes) Is(v string) bool {
	return t.IsFrom(v, CaseTypes.Values...)
}
