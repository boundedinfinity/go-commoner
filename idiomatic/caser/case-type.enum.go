//////////////////////////////////////////////////////////////////
///                                                              /
///                          DO NOT EDIT                         /
///                                                              /
///              Manual changes will be overwritten.             /
///                                                              /
///        Generated by github.com/boundedinfinity/enumer        /
///                                                              /
//////////////////////////////////////////////////////////////////

package caser

import (
	"database/sql/driver"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"strings"
)

//////////////////////////////////////////////////////////////////
///                                                              /
///                             Type                             /
///                                                              /
//////////////////////////////////////////////////////////////////

type CaseType string

//////////////////////////////////////////////////////////////////
///                                                              /
///                    Stringer implemenation                    /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t CaseType) String() string {
	return string(t)
}

//////////////////////////////////////////////////////////////////
///                                                              /
///             JSON marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t CaseType) MarshalJSON() ([]byte, error) {
	return json.Marshal(string(t))
}

func (t *CaseType) UnmarshalJSON(data []byte) error {
	var s string

	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	found, err := CaseTypes.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///             YAML marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t CaseType) MarshalYAML() (interface{}, error) {
	return string(t), nil
}

func (t *CaseType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string

	if err := unmarshal(&s); err != nil {
		return err
	}

	found, err := CaseTypes.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///              XML marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t CaseType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(string(t), start)
}

func (t *CaseType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var s string

	if err := d.DecodeElement(&s, &start); err != nil {
		return err
	}

	found, err := CaseTypes.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///              SQL marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t CaseType) Value() (driver.Value, error) {
	return string(t), nil
}

func (t *CaseType) Scan(value interface{}) error {
	if value == nil {
		return CaseTypes.errf(value)
	}

	dv, err := driver.String.ConvertValue(value)

	if err != nil {
		return err
	}

	s, ok := dv.(string)

	if !ok {
		return CaseTypes.errf(value)
	}

	found, err := CaseTypes.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///                       Companion struct                       /
///                                                              /
//////////////////////////////////////////////////////////////////

var CaseTypes = caseTypes{
	Camel:      CaseType("camel"),
	Err:        fmt.Errorf("invalid CaseType"),
	Kebab:      CaseType("kebab"),
	KebabLower: CaseType("kebab-lower"),
	KebabUpper: CaseType("kebab-upper"),
	Pascal:     CaseType("pascal"),
	Phrase:     CaseType("phrase"),
	Snake:      CaseType("snake"),
	SnakeLower: CaseType("snake-lower"),
	SnakeUpper: CaseType("snake-upper"),
	Unknown:    CaseType("unknown"),
}

type caseTypes struct {
	Err        error
	errf       func(any, ...CaseType) error
	parseMap   map[CaseType][]string
	Camel      CaseType
	Kebab      CaseType
	KebabLower CaseType
	KebabUpper CaseType
	Pascal     CaseType
	Phrase     CaseType
	Snake      CaseType
	SnakeLower CaseType
	SnakeUpper CaseType
	Unknown    CaseType
}

func (t caseTypes) Values() []CaseType {
	return []CaseType{
		CaseTypes.Camel,
		CaseTypes.Kebab,
		CaseTypes.KebabLower,
		CaseTypes.KebabUpper,
		CaseTypes.Pascal,
		CaseTypes.Phrase,
		CaseTypes.Snake,
		CaseTypes.SnakeLower,
		CaseTypes.SnakeUpper,
		CaseTypes.Unknown,
	}
}

func (t caseTypes) ParseFrom(v string, items ...CaseType) (CaseType, error) {
	var found CaseType
	var ok bool

	for _, item := range items {
		matchers, ok2 := t.parseMap[item]

		if !ok2 {
			continue
		}

		for _, matcher := range matchers {
			if v == matcher {
				found = item
				ok = true
				break
			}
		}

		if !ok {
			return found, t.errf(v, items...)
		}

		return found, nil
	}

	return found, nil
}

func (t caseTypes) Parse(v string) (CaseType, error) {
	return t.ParseFrom(v, t.Values()...)
}

func (t caseTypes) IsFrom(v string, items ...CaseType) bool {
	_, err := t.ParseFrom(v, items...)
	return err == nil
}

func (t caseTypes) Is(v string) bool {
	return t.IsFrom(v, t.Values()...)
}

//////////////////////////////////////////////////////////////////
///                                                              /
///                        Initialization                        /
///                                                              /
//////////////////////////////////////////////////////////////////

func init() {
	CaseTypes.parseMap = map[CaseType][]string{
		CaseTypes.Camel:      {"camel", "Camel"},
		CaseTypes.Kebab:      {"kebab", "Kebab"},
		CaseTypes.KebabLower: {"kebab-lower", "KebabLower"},
		CaseTypes.KebabUpper: {"kebab-upper", "KebabUpper"},
		CaseTypes.Pascal:     {"pascal", "Pascal"},
		CaseTypes.Phrase:     {"phrase", "Phrase"},
		CaseTypes.Snake:      {"snake", "Snake"},
		CaseTypes.SnakeLower: {"snake-lower", "SnakeLower"},
		CaseTypes.SnakeUpper: {"snake-upper", "SnakeUpper"},
		CaseTypes.Unknown:    {"unknown", "Unknown"},
	}

	CaseTypes.errf = func(v any, items ...CaseType) error {
		var xs []string

		for _, item := range items {
			if x, ok := CaseTypes.parseMap[item]; ok {
				xs = append(xs, x...)
			}
		}

		return fmt.Errorf(
			"%w: %v is not one of %s",
			CaseTypes.Err,
			v,
			strings.Join(xs, ","),
		)
	}
}
