//************************************************************************************
//*                                                                                  *
//* ===== DO NOT EDIT =====                                                          *
//* Manual changes will be overwritten.                                              *
//* Generated by github.com/boundedinfinity/enumer                                   *
//*                                                                                  *
//************************************************************************************

package measurement

import (
	"database/sql/driver"
	"encoding/xml"
	"fmt"

	"github.com/boundedinfinity/enumer"
)

type MetricUnit string

// /////////////////////////////////////////////////////////////////
//  MetricUnit Stringer implemenation
// /////////////////////////////////////////////////////////////////

func (t MetricUnit) String() string {
	return string(t)
}

// /////////////////////////////////////////////////////////////////
//  MetricUnit JSON marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t MetricUnit) MarshalJSON() ([]byte, error) {
	return enumer.MarshalJSON(t)
}

func (t *MetricUnit) UnmarshalJSON(data []byte) error {
	return enumer.UnmarshalJSON(data, t, MetricUnits.Parse)
}

// /////////////////////////////////////////////////////////////////
//  MetricUnit YAML marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t MetricUnit) MarshalYAML() (interface{}, error) {
	return enumer.MarshalYAML(t)
}

func (t *MetricUnit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	return enumer.UnmarshalYAML(unmarshal, t, MetricUnits.Parse)
}

// /////////////////////////////////////////////////////////////////
//  MetricUnit XML marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t MetricUnit) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return enumer.MarshalXML(t, e, start)
}

func (t *MetricUnit) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	return enumer.UnmarshalXML(t, MetricUnits.Parse, d, start)
}

// /////////////////////////////////////////////////////////////////
//  MetricUnit SQL Database marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t MetricUnit) Value() (driver.Value, error) {
	return enumer.Value(t)
}

func (t *MetricUnit) Scan(value interface{}) error {
	return enumer.Scan(value, t, MetricUnits.Parse)
}

// /////////////////////////////////////////////////////////////////
//
//  Enumeration
//
// /////////////////////////////////////////////////////////////////

type metricUnits struct {
	Tera   MetricUnit
	Giga   MetricUnit
	Mega   MetricUnit
	Kilo   MetricUnit
	Hecto  MetricUnit
	Deca   MetricUnit
	Unit   MetricUnit
	Deci   MetricUnit
	Centi  MetricUnit
	Milli  MetricUnit
	Micro  MetricUnit
	Nano   MetricUnit
	Pico   MetricUnit
	Values []MetricUnit
	Err    error
}

var MetricUnits = metricUnits{
	Tera:  MetricUnit("Tera"),
	Giga:  MetricUnit("Giga"),
	Mega:  MetricUnit("Mega"),
	Kilo:  MetricUnit("Kilo"),
	Hecto: MetricUnit("Hecto"),
	Deca:  MetricUnit("Deca"),
	Unit:  MetricUnit("Unit"),
	Deci:  MetricUnit("Deci"),
	Centi: MetricUnit("Centi"),
	Milli: MetricUnit("Milli"),
	Micro: MetricUnit("Micro"),
	Nano:  MetricUnit("Nano"),
	Pico:  MetricUnit("Pico"),
	Err:   fmt.Errorf("invalid MetricUnit"),
}

func init() {
	MetricUnits.Values = []MetricUnit{
		MetricUnits.Tera,
		MetricUnits.Giga,
		MetricUnits.Mega,
		MetricUnits.Kilo,
		MetricUnits.Hecto,
		MetricUnits.Deca,
		MetricUnits.Unit,
		MetricUnits.Deci,
		MetricUnits.Centi,
		MetricUnits.Milli,
		MetricUnits.Micro,
		MetricUnits.Nano,
		MetricUnits.Pico,
	}
}

func (t metricUnits) newErr(a any, values ...MetricUnit) error {
	return fmt.Errorf(
		"invalid %w value '%v'. Must be one of %v",
		MetricUnits.Err,
		a,
		enumer.Join(values, ", "),
	)
}

func (t metricUnits) ParseFrom(v string, values ...MetricUnit) (MetricUnit, error) {
	var found MetricUnit
	var ok bool

	for _, value := range values {
		if enumer.IsEq[string, MetricUnit](v)(value) {
			found = value
			ok = true
			break
		}
	}

	if !ok {
		return found, t.newErr(v, values...)
	}

	return found, nil
}

func (t metricUnits) Parse(v string) (MetricUnit, error) {
	return t.ParseFrom(v, MetricUnits.Values...)
}

func (t metricUnits) IsFrom(v string, values ...MetricUnit) bool {
	for _, value := range values {
		if enumer.IsEq[string, MetricUnit](v)(value) {
			return true
		}
	}
	return false
}

func (t metricUnits) Is(v string) bool {
	return t.IsFrom(v, MetricUnits.Values...)
}
