//////////////////////////////////////////////////////////////////
///                                                              /
///                          DO NOT EDIT                         /
///                                                              /
///              Manual changes will be overwritten.             /
///                                                              /
///        Generated by github.com/boundedinfinity/enumer        /
///                                                              /
//////////////////////////////////////////////////////////////////

package measurement

import (
	"database/sql/driver"
	"encoding/json"
	"encoding/xml"
	errorer "github.com/boundedinfinity/go-commoner/errorer"
	"strings"
)

//////////////////////////////////////////////////////////////////
///                                                              /
///                             Type                             /
///                                                              /
//////////////////////////////////////////////////////////////////

type MetricUnit string

//////////////////////////////////////////////////////////////////
///                                                              /
///                    Stringer implemenation                    /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t MetricUnit) String() string {
	return string(t)
}

//////////////////////////////////////////////////////////////////
///                                                              /
///             JSON marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t MetricUnit) MarshalJSON() ([]byte, error) {
	return json.Marshal(string(t))
}

func (t *MetricUnit) UnmarshalJSON(data []byte) error {
	var s string

	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	found, err := MetricUnits.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///             YAML marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t MetricUnit) MarshalYAML() (interface{}, error) {
	return string(t), nil
}

func (t *MetricUnit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string

	if err := unmarshal(&s); err != nil {
		return err
	}

	found, err := MetricUnits.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///              XML marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t MetricUnit) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(string(t), start)
}

func (t *MetricUnit) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var s string

	if err := d.DecodeElement(&s, &start); err != nil {
		return err
	}

	found, err := MetricUnits.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///              SQL marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t MetricUnit) Value() (driver.Value, error) {
	return string(t), nil
}

func (t *MetricUnit) Scan(value interface{}) error {
	if value == nil {
		return MetricUnits.errf(value)
	}

	dv, err := driver.String.ConvertValue(value)

	if err != nil {
		return err
	}

	s, ok := dv.(string)

	if !ok {
		return MetricUnits.errf(value)
	}

	found, err := MetricUnits.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///                       Companion struct                       /
///                                                              /
//////////////////////////////////////////////////////////////////

var MetricUnits = metricUnits{
	Err:     errorer.New("invalid MetricUnit"),
	Invalid: MetricUnit("invalid"),
	Tera:    MetricUnit("tera"),
	Giga:    MetricUnit("giga"),
	Mega:    MetricUnit("mega"),
	Kilo:    MetricUnit("kilo"),
	Hecto:   MetricUnit("hecto"),
	Deca:    MetricUnit("deca"),
	Unit:    MetricUnit("unit"),
	Deci:    MetricUnit("deci"),
	Centi:   MetricUnit("centi"),
	Milli:   MetricUnit("milli"),
	Micro:   MetricUnit("micro"),
	Nano:    MetricUnit("nano"),
	Pico:    MetricUnit("pico"),
}

type metricUnits struct {
	Err      error
	errf     func(...any) error
	parseMap map[MetricUnit][]string
	Invalid  MetricUnit
	Tera     MetricUnit
	Giga     MetricUnit
	Mega     MetricUnit
	Kilo     MetricUnit
	Hecto    MetricUnit
	Deca     MetricUnit
	Unit     MetricUnit
	Deci     MetricUnit
	Centi    MetricUnit
	Milli    MetricUnit
	Micro    MetricUnit
	Nano     MetricUnit
	Pico     MetricUnit
}

func (t metricUnits) Values() []MetricUnit {
	return []MetricUnit{
		MetricUnits.Tera,
		MetricUnits.Giga,
		MetricUnits.Mega,
		MetricUnits.Kilo,
		MetricUnits.Hecto,
		MetricUnits.Deca,
		MetricUnits.Unit,
		MetricUnits.Deci,
		MetricUnits.Centi,
		MetricUnits.Milli,
		MetricUnits.Micro,
		MetricUnits.Nano,
		MetricUnits.Pico,
	}
}

func (t metricUnits) ToStrings(items ...MetricUnit) []string {
	var results []string

	for _, item := range items {
		results = append(results, item.String())
	}

	return results
}

func (t metricUnits) ParseFrom(v string, items ...MetricUnit) (MetricUnit, error) {
	found := t.Invalid
	var ok bool

	for _, item := range items {
		matchers, ok2 := t.parseMap[item]

		if !ok2 {
			continue
		}

		for _, matcher := range matchers {
			if v == matcher {
				found = item
				ok = true
				break
			}
		}

		if ok {
			break
		}
	}

	if !ok {
		list := strings.Join(t.ToStrings(items...), ",")
		return found, t.errf(v, list)
	}

	return found, nil
}

func (t metricUnits) Parse(v string) (MetricUnit, error) {
	return t.ParseFrom(v, t.Values()...)
}

func (t metricUnits) IsFrom(v string, items ...MetricUnit) bool {
	_, err := t.ParseFrom(v, items...)
	return err == nil
}

func (t metricUnits) Is(v string) bool {
	return t.IsFrom(v, t.Values()...)
}

//////////////////////////////////////////////////////////////////
///                                                              /
///                        Initialization                        /
///                                                              /
//////////////////////////////////////////////////////////////////

func init() {
	MetricUnits.parseMap = map[MetricUnit][]string{
		MetricUnits.Centi: {"centi", "Centi"},
		MetricUnits.Deca:  {"deca", "Deca"},
		MetricUnits.Deci:  {"deci", "Deci"},
		MetricUnits.Giga:  {"giga", "Giga"},
		MetricUnits.Hecto: {"hecto", "Hecto"},
		MetricUnits.Kilo:  {"kilo", "Kilo"},
		MetricUnits.Mega:  {"mega", "Mega"},
		MetricUnits.Micro: {"micro", "Micro"},
		MetricUnits.Milli: {"milli", "Milli"},
		MetricUnits.Nano:  {"nano", "Nano"},
		MetricUnits.Pico:  {"pico", "Pico"},
		MetricUnits.Tera:  {"tera", "Tera"},
		MetricUnits.Unit:  {"unit", "Unit"},
	}

	MetricUnits.errf = MetricUnits.Err.(*errorer.Errorer).FormatFn("%v is not one of %s")
}
