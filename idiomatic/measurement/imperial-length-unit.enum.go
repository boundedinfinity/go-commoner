//////////////////////////////////////////////////////////////////
///                                                              /
///                          DO NOT EDIT                         /
///                                                              /
///              Manual changes will be overwritten.             /
///                                                              /
///        Generated by github.com/boundedinfinity/enumer        /
///                                                              /
//////////////////////////////////////////////////////////////////

package measurement

import (
	"database/sql/driver"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"strings"
)

//////////////////////////////////////////////////////////////////
///                                                              /
///                             Type                             /
///                                                              /
//////////////////////////////////////////////////////////////////

type ImperialLengthUnit string

//////////////////////////////////////////////////////////////////
///                                                              /
///                    Stringer implemenation                    /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t ImperialLengthUnit) String() string {
	return string(t)
}

//////////////////////////////////////////////////////////////////
///                                                              /
///             JSON marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t ImperialLengthUnit) MarshalJSON() ([]byte, error) {
	return json.Marshal(string(t))
}

func (t *ImperialLengthUnit) UnmarshalJSON(data []byte) error {
	var s string

	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	found, err := ImperialLengthUnits.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///             YAML marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t ImperialLengthUnit) MarshalYAML() (interface{}, error) {
	return string(t), nil
}

func (t *ImperialLengthUnit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string

	if err := unmarshal(&s); err != nil {
		return err
	}

	found, err := ImperialLengthUnits.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///              XML marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t ImperialLengthUnit) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(string(t), start)
}

func (t *ImperialLengthUnit) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var s string

	if err := d.DecodeElement(&s, &start); err != nil {
		return err
	}

	found, err := ImperialLengthUnits.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///              SQL marshal/unmarshal implemenation             /
///                                                              /
//////////////////////////////////////////////////////////////////

func (t ImperialLengthUnit) Value() (driver.Value, error) {
	return string(t), nil
}

func (t *ImperialLengthUnit) Scan(value interface{}) error {
	if value == nil {
		return ImperialLengthUnits.errf(value)
	}

	dv, err := driver.String.ConvertValue(value)

	if err != nil {
		return err
	}

	s, ok := dv.(string)

	if !ok {
		return ImperialLengthUnits.errf(value)
	}

	found, err := ImperialLengthUnits.Parse(s)

	if err != nil {
		return err
	}

	*t = found
	return nil
}

//////////////////////////////////////////////////////////////////
///                                                              /
///                       Companion struct                       /
///                                                              /
//////////////////////////////////////////////////////////////////

var ImperialLengthUnits = imperialLengthUnits{
	Barleycorn:   ImperialLengthUnit("barleycorn"),
	Cable:        ImperialLengthUnit("cable"),
	Chain:        ImperialLengthUnit("chain"),
	Err:          fmt.Errorf("invalid ImperialLengthUnit"),
	Fathom:       ImperialLengthUnit("fathom"),
	Foot:         ImperialLengthUnit("foot"),
	Furlong:      ImperialLengthUnit("furlong"),
	Hand:         ImperialLengthUnit("hand"),
	Inch:         ImperialLengthUnit("inch"),
	League:       ImperialLengthUnit("league"),
	Link:         ImperialLengthUnit("link"),
	Mile:         ImperialLengthUnit("mile"),
	NauticalMile: ImperialLengthUnit("nautical-mile"),
	Rod:          ImperialLengthUnit("rod"),
	Thou:         ImperialLengthUnit("thou"),
	Twip:         ImperialLengthUnit("twip"),
	Yard:         ImperialLengthUnit("yard"),
}

type imperialLengthUnits struct {
	Err          error
	errf         func(any, ...ImperialLengthUnit) error
	parseMap     map[ImperialLengthUnit][]string
	Twip         ImperialLengthUnit
	Thou         ImperialLengthUnit
	Barleycorn   ImperialLengthUnit
	Inch         ImperialLengthUnit
	Hand         ImperialLengthUnit
	Foot         ImperialLengthUnit
	Yard         ImperialLengthUnit
	Chain        ImperialLengthUnit
	Furlong      ImperialLengthUnit
	Mile         ImperialLengthUnit
	League       ImperialLengthUnit
	Fathom       ImperialLengthUnit
	Cable        ImperialLengthUnit
	NauticalMile ImperialLengthUnit
	Link         ImperialLengthUnit
	Rod          ImperialLengthUnit
}

func (t imperialLengthUnits) Values() []ImperialLengthUnit {
	return []ImperialLengthUnit{
		ImperialLengthUnits.Twip,
		ImperialLengthUnits.Thou,
		ImperialLengthUnits.Barleycorn,
		ImperialLengthUnits.Inch,
		ImperialLengthUnits.Hand,
		ImperialLengthUnits.Foot,
		ImperialLengthUnits.Yard,
		ImperialLengthUnits.Chain,
		ImperialLengthUnits.Furlong,
		ImperialLengthUnits.Mile,
		ImperialLengthUnits.League,
		ImperialLengthUnits.Fathom,
		ImperialLengthUnits.Cable,
		ImperialLengthUnits.NauticalMile,
		ImperialLengthUnits.Link,
		ImperialLengthUnits.Rod,
	}
}

func (t imperialLengthUnits) ParseFrom(v string, items ...ImperialLengthUnit) (ImperialLengthUnit, error) {
	var found ImperialLengthUnit
	var ok bool

	for _, item := range items {
		matchers, ok2 := t.parseMap[item]

		if !ok2 {
			continue
		}

		for _, matcher := range matchers {
			if v == matcher {
				found = item
				ok = true
				break
			}
		}

		if !ok {
			return found, t.errf(v, items...)
		}

		return found, nil
	}

	return found, nil
}

func (t imperialLengthUnits) Parse(v string) (ImperialLengthUnit, error) {
	return t.ParseFrom(v, t.Values()...)
}

func (t imperialLengthUnits) IsFrom(v string, items ...ImperialLengthUnit) bool {
	_, err := t.ParseFrom(v, items...)
	return err == nil
}

func (t imperialLengthUnits) Is(v string) bool {
	return t.IsFrom(v, t.Values()...)
}

//////////////////////////////////////////////////////////////////
///                                                              /
///                        Initialization                        /
///                                                              /
//////////////////////////////////////////////////////////////////

func init() {
	ImperialLengthUnits.parseMap = map[ImperialLengthUnit][]string{
		ImperialLengthUnits.Barleycorn:   {"barleycorn", "Barleycorn"},
		ImperialLengthUnits.Cable:        {"cable", "Cable"},
		ImperialLengthUnits.Chain:        {"chain", "Chain"},
		ImperialLengthUnits.Fathom:       {"fathom", "Fathom"},
		ImperialLengthUnits.Foot:         {"foot", "Foot"},
		ImperialLengthUnits.Furlong:      {"furlong", "Furlong"},
		ImperialLengthUnits.Hand:         {"hand", "Hand"},
		ImperialLengthUnits.Inch:         {"inch", "Inch"},
		ImperialLengthUnits.League:       {"league", "League"},
		ImperialLengthUnits.Link:         {"link", "Link"},
		ImperialLengthUnits.Mile:         {"mile", "Mile"},
		ImperialLengthUnits.NauticalMile: {"nautical-mile", "NauticalMile"},
		ImperialLengthUnits.Rod:          {"rod", "Rod"},
		ImperialLengthUnits.Thou:         {"thou", "Thou"},
		ImperialLengthUnits.Twip:         {"twip", "Twip"},
		ImperialLengthUnits.Yard:         {"yard", "Yard"},
	}

	ImperialLengthUnits.errf = func(v any, items ...ImperialLengthUnit) error {
		var xs []string

		for _, item := range items {
			if x, ok := ImperialLengthUnits.parseMap[item]; ok {
				xs = append(xs, x...)
			}
		}

		return fmt.Errorf(
			"%w: %v is not one of %s",
			ImperialLengthUnits.Err,
			v,
			strings.Join(xs, ","),
		)
	}
}
